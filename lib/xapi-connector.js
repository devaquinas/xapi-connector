// Generated by CoffeeScript 1.7.1
(function() {
  var Connector, dispatcher, print, tls,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  tls = require('tls');

  dispatcher = require('./dispatcher.js');

  print = function(msg) {
    console.log(msg + '\n');
  };

  Connector = (function() {
    function Connector(server_url, conn_port, stream_port, username, password) {
      this.server_url = server_url;
      this.conn_port = conn_port;
      this.stream_port = stream_port;
      this.username = username;
      this.password = password;
      this.onStreamChunk = __bind(this.onStreamChunk, this);
      this.onChunk = __bind(this.onChunk, this);
      this.conn = {};
      this.stream = {};
      this.msg = '';
      this.msg_id = 0;
      this.stream_msg = '';
      this.env = {
        messages: {}
      };
    }

    Connector.prototype.buildCommand = function(command, args, tag) {
      var com;
      this.msg_id += 1;
      com = {
        command: (function() {
          if (command != null) {
            return command;
          } else {
            throw new Error('Missing command');
          }
        })(),
        "arguments": args != null ? args : void 0
      };
      if (tag != null) {
        com.customTag = tag;
      } else {
        com.customTag = this.msg_id.toString();
      }
      this.env.messages[this.msg_id] = com;
      return JSON.stringify(com);
    };

    Connector.prototype.buildStreamCommand = function(command, stream_session_id, symbols) {
      var com;
      com = {
        command: (function() {
          if (command != null) {
            return command;
          } else {
            throw new Error('Missing command');
          }
        })()
      };
      if (stream_session_id != null) {
        com.streamSessionId = stream_session_id;
      }
      if (symbols != null) {
        com.symbols = symbols;
      }
      return JSON.stringify(com);
    };

    Connector.prototype.connect = function() {
      this.conn._socket = tls.connect(this.conn_port, this.server_url, this.onOpen);
      this.conn._socket.setEncoding('utf-8');
      this.conn.dispatcher = new dispatcher(this.conn._socket, 200);
      this.conn.send = (function(_this) {
        return function(msg) {
          return _this.conn.dispatcher.add(msg);
        };
      })(this);
      this.conn._socket.addListener('data', this.onChunk);
      this.conn._socket.addListener('error', this.onError);
      this.conn._socket.addListener('close', this.onClose);
      this.conn.end = (function(_this) {
        return function() {
          if (_this.stream._socket != null) {
            _this.stream._socket.end();
          }
          return _this.conn._socket.end();
        };
      })(this);
    };

    Connector.prototype.onChunk = function(data) {
      var res, responses, _i, _len;
      responses = data.split('\n\n');
      if (responses.length === 1) {
        this.msg += responses[0];
      } else {
        responses = (function() {
          var _i, _len, _ref, _results;
          _ref = data.split('\n\n');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            res = _ref[_i];
            if (res !== '') {
              _results.push(res);
            }
          }
          return _results;
        })();
        for (_i = 0, _len = responses.length; _i < _len; _i++) {
          res = responses[_i];
          this.msg += res;
          this.onMessage(this.msg);
          this.msg = '';
        }
      }
    };

    Connector.prototype.disconnect = function() {
      this.conn.end();
    };

    Connector.prototype.connectStream = function() {
      this.stream._socket = tls.connect(this.stream_port, this.server_url, this.onStreamOpen);
      this.stream._socket.setEncoding('utf-8');
      this.stream.dispatcher = new dispatcher(this.stream._socket, 200);
      this.stream.send = (function(_this) {
        return function(msg) {
          return _this.stream.dispatcher.add(msg);
        };
      })(this);
      this.stream._socket.addListener('data', this.onStreamChunk);
      this.stream._socket.addListener('error', this.onStreamError);
      this.stream._socket.addListener('close', this.onStreamClose);
      this.stream.end = (function(_this) {
        return function() {
          return _this.stream._socket.end();
        };
      })(this);
    };

    Connector.prototype.onStreamChunk = function(data) {
      var res, responses, _i, _len;
      responses = data.split('\n\n');
      if (responses.length === 1) {
        this.stream_msg += responses[0];
      } else {
        responses = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = responses.length; _i < _len; _i++) {
            res = responses[_i];
            if (res !== '') {
              _results.push(res);
            }
          }
          return _results;
        })();
        for (_i = 0, _len = responses.length; _i < _len; _i++) {
          res = responses[_i];
          this.stream_msg += res;
          this.onStreamMessage(this.stream_msg);
          this.stream_msg = '';
        }
      }
    };

    Connector.prototype.disconnectStream = function() {
      this.stream.end();
    };

    Connector.prototype.resetState = function() {
      this.conn = {};
      this.stream = {};
      this.msg = '';
      this.msg_id = 0;
      this.stream_msg = '';
      return this.env = {
        messages: {}
      };
    };

    return Connector;

  })();

  module.exports = Connector;

}).call(this);
